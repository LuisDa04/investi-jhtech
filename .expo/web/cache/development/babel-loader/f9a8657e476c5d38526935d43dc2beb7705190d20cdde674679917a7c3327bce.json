{"ast":null,"code":"import * as SecureStore from \"expo-secure-store\";\nexport const urls = {\n  REST_URL: \"https://paoliakwfoczcallnecf.supabase.co/rest/v1\",\n  AUTH_URL: \"https://paoliakwfoczcallnecf.supabase.co/auth/v1\",\n  STORAGE_URL: \"https://paoliakwfoczcallnecf.supabase.co/storage/v1\"\n};\nexport const ANON_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBhb2xpYWt3Zm9jemNhbGxuZWNmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ2MzA5ODYsImV4cCI6MjA3MDIwNjk4Nn0.zCJoTHcWKZB9vpy5Vn231PNsNSLzmnPvFBKTkNlgG4o\";\nconst TOKEN_KEYS = {\n  ACCESS_TOKEN: \"access_token\",\n  REFRESH_TOKEN: \"refresh_token\",\n  SUPABASE_AUTH_TOKEN: \"supabase.auth.token\",\n  SUPABASE_REFRESH_TOKEN: \"supabase.auth.refresh_token\",\n  TOKEN_EXPIRY: \"token_expiry\",\n  USER_SESSION: \"user_session\"\n};\nfunction isTokenExpired(token) {\n  try {\n    const payload = JSON.parse(atob(token.split(\".\")[1]));\n    const currentTime = Math.floor(Date.now() / 1000);\n    return payload.exp <= currentTime + 300;\n  } catch {\n    return true;\n  }\n}\nasync function storeTokens(accessToken, refreshToken) {\n  const promises = [SecureStore.setItemAsync(TOKEN_KEYS.ACCESS_TOKEN, accessToken), SecureStore.setItemAsync(TOKEN_KEYS.SUPABASE_AUTH_TOKEN, accessToken)];\n  if (refreshToken) {\n    promises.push(SecureStore.setItemAsync(TOKEN_KEYS.REFRESH_TOKEN, refreshToken), SecureStore.setItemAsync(TOKEN_KEYS.SUPABASE_REFRESH_TOKEN, refreshToken));\n  }\n  try {\n    const payload = JSON.parse(atob(accessToken.split(\".\")[1]));\n    if (payload.exp) {\n      promises.push(SecureStore.setItemAsync(TOKEN_KEYS.TOKEN_EXPIRY, payload.exp.toString()));\n    }\n  } catch (error) {\n    console.warn(\"Could not parse token expiry:\", error);\n  }\n  await Promise.all(promises);\n}\nasync function clearTokens() {\n  const promises = Object.values(TOKEN_KEYS).map(key => SecureStore.deleteItemAsync(key).catch(() => {}));\n  await Promise.all(promises);\n}\nasync function refreshAccessToken() {\n  try {\n    const refreshToken = await SecureStore.getItemAsync(TOKEN_KEYS.REFRESH_TOKEN);\n    if (!refreshToken) return null;\n    const response = await fetch(`${urls.AUTH_URL}/token?grant_type=refresh_token`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        apikey: ANON_KEY\n      },\n      body: JSON.stringify({\n        refresh_token: refreshToken\n      })\n    });\n    if (!response.ok) {\n      await clearTokens();\n      return null;\n    }\n    const data = await response.json();\n    if (data.access_token) {\n      await storeTokens(data.access_token, data.refresh_token || refreshToken);\n      return data.access_token;\n    }\n    return null;\n  } catch (error) {\n    console.error(\"Error refreshing token:\", error);\n    return null;\n  }\n}\nasync function getValidAccessToken() {\n  try {\n    let accessToken = await SecureStore.getItemAsync(TOKEN_KEYS.ACCESS_TOKEN);\n    if (!accessToken) return null;\n    if (isTokenExpired(accessToken)) {\n      console.log(\"Token expired, attempting refresh...\");\n      accessToken = await refreshAccessToken();\n    }\n    return accessToken;\n  } catch (error) {\n    console.error(\"Error getting valid access token:\", error);\n    return null;\n  }\n}\nconst requestMetrics = [];\nexport function getRequestMetrics() {\n  return [...requestMetrics];\n}\nexport function clearRequestMetrics() {\n  requestMetrics.length = 0;\n}\nexport async function request(method, path, options = {}) {\n  const startTime = Date.now();\n  let status = 0;\n  const {\n    params,\n    body,\n    headers = {},\n    binary = false,\n    retryOnAuth = true,\n    timeout = 30000\n  } = options;\n  try {\n    let url = `${urls.REST_URL}${path}`;\n    if (params) {\n      const searchParams = new URLSearchParams();\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          searchParams.append(key, String(value));\n        }\n      });\n      if (searchParams.toString()) {\n        url += `?${searchParams.toString()}`;\n      }\n    }\n    const requestHeaders = Object.assign({\n      apikey: ANON_KEY\n    }, headers);\n    const token = await getValidAccessToken();\n    if (token) {\n      requestHeaders[\"Authorization\"] = `Bearer ${token}`;\n    }\n    if (!binary) {\n      requestHeaders[\"Content-Type\"] = \"application/json\";\n    }\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n    const response = await fetch(url, {\n      method,\n      headers: requestHeaders,\n      body: body ? binary ? body : JSON.stringify(body) : undefined,\n      signal: controller.signal\n    });\n    clearTimeout(timeoutId);\n    if (!response.ok && response.status === 401 && retryOnAuth) {\n      console.log(\"Auth error, attempting token refresh and retry...\");\n      const newToken = await refreshAccessToken();\n      if (newToken) {\n        requestHeaders[\"Authorization\"] = `Bearer ${newToken}`;\n        const retryResponse = await fetch(url, {\n          method,\n          headers: requestHeaders,\n          body: body ? binary ? body : JSON.stringify(body) : undefined\n        });\n        if (retryResponse.ok) {\n          status = 200;\n          try {\n            return await retryResponse.json();\n          } catch {\n            return null;\n          }\n        }\n      }\n    }\n    if (!response.ok) {\n      let errorData;\n      try {\n        errorData = await response.json();\n      } catch {\n        errorData = {\n          message: response.statusText\n        };\n      }\n      status = response.status;\n      throw {\n        code: errorData.code || response.status,\n        message: errorData.message || \"Request failed\",\n        details: errorData.details || null,\n        status: response.status\n      };\n    }\n    status = 200;\n    try {\n      return await response.json();\n    } catch {\n      return null;\n    }\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      throw {\n        code: 'TIMEOUT',\n        message: 'Request timeout',\n        details: `Request took longer than ${timeout}ms`\n      };\n    }\n    status = error.status || 500;\n    throw error;\n  } finally {\n    const duration = Date.now() - startTime;\n    requestMetrics.push({\n      path,\n      method,\n      duration,\n      status,\n      timestamp: startTime\n    });\n    if (requestMetrics.length > 100) {\n      requestMetrics.shift();\n    }\n  }\n}\nexport async function authSignIn(email, password) {\n  const response = await fetch(`${urls.AUTH_URL}/token?grant_type=password`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      apikey: ANON_KEY\n    },\n    body: JSON.stringify({\n      email,\n      password\n    })\n  });\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error_description || \"Sign in failed\");\n  }\n  const data = await response.json();\n  if (data.access_token) {\n    await storeTokens(data.access_token, data.refresh_token);\n    await SecureStore.setItemAsync(TOKEN_KEYS.USER_SESSION, JSON.stringify({\n      email,\n      loginTime: Date.now(),\n      lastActivity: Date.now()\n    }));\n  }\n  return data;\n}\nexport async function authSignUp(email, password) {\n  const response = await fetch(`${urls.AUTH_URL}/signup`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      apikey: ANON_KEY\n    },\n    body: JSON.stringify({\n      email,\n      password\n    })\n  });\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error_description || \"Sign up failed\");\n  }\n  const data = await response.json();\n  if (data.access_token) {\n    await storeTokens(data.access_token, data.refresh_token);\n    await SecureStore.setItemAsync(TOKEN_KEYS.USER_SESSION, JSON.stringify({\n      email,\n      signupTime: Date.now(),\n      lastActivity: Date.now()\n    }));\n  }\n  return data;\n}\nexport async function authSignOut() {\n  try {\n    const token = await SecureStore.getItemAsync(TOKEN_KEYS.ACCESS_TOKEN);\n    if (token) {\n      await fetch(`${urls.AUTH_URL}/logout`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          apikey: ANON_KEY,\n          \"Authorization\": `Bearer ${token}`\n        }\n      }).catch(() => {});\n    }\n  } catch (error) {\n    console.warn(\"Error during server logout:\", error);\n  }\n  await clearTokens();\n}\nexport async function getCurrentUserId() {\n  try {\n    const token = await getValidAccessToken();\n    if (!token) return null;\n    const payload = JSON.parse(atob(token.split(\".\")[1]));\n    return payload.sub || null;\n  } catch (error) {\n    console.error(\"Error getting current user ID:\", error);\n    return null;\n  }\n}\nexport async function isAuthenticated() {\n  try {\n    const token = await getValidAccessToken();\n    return !!token;\n  } catch {\n    return false;\n  }\n}\nexport async function updateLastActivity() {\n  try {\n    const sessionData = await SecureStore.getItemAsync(TOKEN_KEYS.USER_SESSION);\n    if (sessionData) {\n      const session = JSON.parse(sessionData);\n      session.lastActivity = Date.now();\n      await SecureStore.setItemAsync(TOKEN_KEYS.USER_SESSION, JSON.stringify(session));\n    }\n  } catch (error) {\n    console.warn(\"Error updating last activity:\", error);\n  }\n}\nexport async function getSessionInfo() {\n  try {\n    const sessionData = await SecureStore.getItemAsync(TOKEN_KEYS.USER_SESSION);\n    return sessionData ? JSON.parse(sessionData) : null;\n  } catch {\n    return null;\n  }\n}\nexport async function checkNetworkStatus() {\n  if (__DEV__) {\n    return Promise.resolve(true);\n  }\n  try {\n    const response = await fetch(`${urls.REST_URL}/health`, {\n      method: 'HEAD',\n      headers: {\n        'apikey': ANON_KEY,\n        'Authorization': `Bearer ${await getValidAccessToken()}`\n      }\n    });\n    return response.ok;\n  } catch (error) {\n    console.error('Network status check failed:', error);\n    return false;\n  }\n}\nexport async function batchRequest(requests) {\n  const promises = requests.map(req => request(req.method, req.path, req.options).catch(error => ({\n    error\n  })));\n  return await Promise.all(promises);\n}\nexport async function uploadWithProgress(path, file, onProgress) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.upload.addEventListener('progress', event => {\n      if (event.lengthComputable && onProgress) {\n        const progress = event.loaded / event.total * 100;\n        onProgress(progress);\n      }\n    });\n    xhr.addEventListener('load', () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        try {\n          resolve(JSON.parse(xhr.responseText));\n        } catch {\n          resolve(xhr.responseText);\n        }\n      } else {\n        reject(new Error(`Upload failed: ${xhr.status} ${xhr.statusText}`));\n      }\n    });\n    xhr.addEventListener('error', () => {\n      reject(new Error('Upload failed'));\n    });\n    xhr.addEventListener('abort', () => {\n      reject(new Error('Upload cancelled'));\n    });\n    xhr.open('POST', `${urls.STORAGE_URL}${path}`);\n    xhr.setRequestHeader('apikey', ANON_KEY);\n    getValidAccessToken().then(token => {\n      if (token) {\n        xhr.setRequestHeader('Authorization', `Bearer ${token}`);\n      }\n      xhr.send(file);\n    });\n  });\n}\nexport async function requestWithRetry(method, path, options = {}, maxRetries = 3) {\n  let lastError;\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await request(method, path, options);\n    } catch (error) {\n      lastError = error;\n      if (error.status >= 400 && error.status < 500) {\n        throw error;\n      }\n      if (attempt < maxRetries) {\n        const delay = Math.min(1000 * Math.pow(2, attempt), 10000);\n        console.log(`Request failed, retrying in ${delay}ms... (attempt ${attempt + 1}/${maxRetries})`);\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  }\n  throw lastError;\n}\nconst requestCache = new Map();\nexport async function requestWithCache(method, path, options = {}, ttl = 300000) {\n  const cacheKey = `${method}:${path}:${JSON.stringify(options.params || {})}`;\n  const cached = requestCache.get(cacheKey);\n  if (cached && Date.now() - cached.timestamp < cached.ttl) {\n    return cached.data;\n  }\n  try {\n    const data = await request(method, path, options);\n    if (method === 'GET' && data) {\n      requestCache.set(cacheKey, {\n        data,\n        timestamp: Date.now(),\n        ttl\n      });\n    }\n    return data;\n  } catch (error) {\n    if (cached) {\n      console.warn('Request failed, returning cached data:', error);\n      return cached.data;\n    }\n    throw error;\n  }\n}\nexport function clearRequestCache() {\n  requestCache.clear();\n}\nlet isOnline = true;\nlet connectionListeners = [];\nexport function addConnectionListener(callback) {\n  connectionListeners.push(callback);\n}\nexport function removeConnectionListener(callback) {\n  connectionListeners = connectionListeners.filter(cb => cb !== callback);\n}\nexport function getConnectionStatus() {\n  return isOnline;\n}\nsetInterval(async () => {\n  const wasOnline = isOnline;\n  isOnline = await checkNetworkStatus();\n  if (wasOnline !== isOnline) {\n    connectionListeners.forEach(callback => callback(isOnline));\n  }\n}, 30000);\nconst requestQueue = [];\nexport async function queueRequest(method, path, options = {}) {\n  const queuedRequest = {\n    id: `${Date.now()}-${Math.random()}`,\n    method,\n    path,\n    options,\n    timestamp: Date.now(),\n    retries: 0\n  };\n  requestQueue.push(queuedRequest);\n  if (isOnline) {\n    processRequestQueue();\n  }\n  return queuedRequest.id;\n}\nasync function processRequestQueue() {\n  if (!isOnline || requestQueue.length === 0) return;\n  const queuedRequest = requestQueue.shift();\n  if (!queuedRequest) return;\n  try {\n    await requestWithRetry(queuedRequest.method, queuedRequest.path, queuedRequest.options);\n    console.log(`Queued request processed: ${queuedRequest.method} ${queuedRequest.path}`);\n  } catch (error) {\n    console.error(`Failed to process queued request:`, error);\n    if (Date.now() - queuedRequest.timestamp < 3600000 && queuedRequest.retries < 3) {\n      queuedRequest.retries++;\n      requestQueue.push(queuedRequest);\n    }\n  }\n  if (requestQueue.length > 0) {\n    setTimeout(processRequestQueue, 1000);\n  }\n}\naddConnectionListener(online => {\n  if (online) {\n    processRequestQueue();\n  }\n});","map":{"version":3,"names":["SecureStore","urls","REST_URL","AUTH_URL","STORAGE_URL","ANON_KEY","TOKEN_KEYS","ACCESS_TOKEN","REFRESH_TOKEN","SUPABASE_AUTH_TOKEN","SUPABASE_REFRESH_TOKEN","TOKEN_EXPIRY","USER_SESSION","isTokenExpired","token","payload","JSON","parse","atob","split","currentTime","Math","floor","Date","now","exp","storeTokens","accessToken","refreshToken","promises","setItemAsync","push","toString","error","console","warn","Promise","all","clearTokens","Object","values","map","key","deleteItemAsync","catch","refreshAccessToken","getItemAsync","response","fetch","method","headers","apikey","body","stringify","refresh_token","ok","data","json","access_token","getValidAccessToken","log","requestMetrics","getRequestMetrics","clearRequestMetrics","length","request","path","options","startTime","status","params","binary","retryOnAuth","timeout","url","searchParams","URLSearchParams","entries","forEach","value","undefined","append","String","requestHeaders","assign","controller","AbortController","timeoutId","setTimeout","abort","signal","clearTimeout","newToken","retryResponse","errorData","message","statusText","code","details","name","duration","timestamp","shift","authSignIn","email","password","Error","error_description","loginTime","lastActivity","authSignUp","signupTime","authSignOut","getCurrentUserId","sub","isAuthenticated","updateLastActivity","sessionData","session","getSessionInfo","checkNetworkStatus","__DEV__","resolve","batchRequest","requests","req","uploadWithProgress","file","onProgress","reject","xhr","XMLHttpRequest","upload","addEventListener","event","lengthComputable","progress","loaded","total","responseText","open","setRequestHeader","then","send","requestWithRetry","maxRetries","lastError","attempt","delay","min","pow","requestCache","Map","requestWithCache","ttl","cacheKey","cached","get","set","clearRequestCache","clear","isOnline","connectionListeners","addConnectionListener","callback","removeConnectionListener","filter","cb","getConnectionStatus","setInterval","wasOnline","requestQueue","queueRequest","queuedRequest","id","random","retries","processRequestQueue","online"],"sources":["C:/Users/invit/Downloads/investi-app/src/rest/client.ts"],"sourcesContent":["import * as SecureStore from \"expo-secure-store\"  \n  \nexport const urls = {  \n  REST_URL: \"https://paoliakwfoczcallnecf.supabase.co/rest/v1\",  \n  AUTH_URL: \"https://paoliakwfoczcallnecf.supabase.co/auth/v1\",  \n  STORAGE_URL: \"https://paoliakwfoczcallnecf.supabase.co/storage/v1\",  \n}  \n  \nexport const ANON_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBhb2xpYWt3Zm9jemNhbGxuZWNmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ2MzA5ODYsImV4cCI6MjA3MDIwNjk4Nn0.zCJoTHcWKZB9vpy5Vn231PNsNSLzmnPvFBKTkNlgG4o\"  \n  \n// Token storage keys  \nconst TOKEN_KEYS = {  \n  ACCESS_TOKEN: \"access_token\",  \n  REFRESH_TOKEN: \"refresh_token\",  \n  SUPABASE_AUTH_TOKEN: \"supabase.auth.token\",  \n  SUPABASE_REFRESH_TOKEN: \"supabase.auth.refresh_token\",  \n  TOKEN_EXPIRY: \"token_expiry\",  \n  USER_SESSION: \"user_session\"  \n}  \n  \n// Helper function to check if token is expired  \nfunction isTokenExpired(token: string): boolean {  \n  try {  \n    const payload = JSON.parse(atob(token.split(\".\")[1]))  \n    const currentTime = Math.floor(Date.now() / 1000)  \n    return payload.exp <= (currentTime + 300)  \n  } catch {  \n    return true  \n  }  \n}  \n  \n// Helper function to store all token variants  \nasync function storeTokens(accessToken: string, refreshToken?: string) {  \n  const promises = [  \n    SecureStore.setItemAsync(TOKEN_KEYS.ACCESS_TOKEN, accessToken),  \n    SecureStore.setItemAsync(TOKEN_KEYS.SUPABASE_AUTH_TOKEN, accessToken)  \n  ]  \n  \n  if (refreshToken) {  \n    promises.push(  \n      SecureStore.setItemAsync(TOKEN_KEYS.REFRESH_TOKEN, refreshToken),  \n      SecureStore.setItemAsync(TOKEN_KEYS.SUPABASE_REFRESH_TOKEN, refreshToken)  \n    )  \n  }  \n  \n  try {  \n    const payload = JSON.parse(atob(accessToken.split(\".\")[1]))  \n    if (payload.exp) {  \n      promises.push(  \n        SecureStore.setItemAsync(TOKEN_KEYS.TOKEN_EXPIRY, payload.exp.toString())  \n      )  \n    }  \n  } catch (error) {  \n    console.warn(\"Could not parse token expiry:\", error)  \n  }  \n  \n  await Promise.all(promises)  \n}  \n  \n// Helper function to clear all tokens  \nasync function clearTokens() {  \n  const promises = Object.values(TOKEN_KEYS).map(key =>  \n    SecureStore.deleteItemAsync(key).catch(() => {})  \n  )  \n  await Promise.all(promises)  \n}  \n  \n// Refresh token function  \nasync function refreshAccessToken(): Promise<string | null> {  \n  try {  \n    const refreshToken = await SecureStore.getItemAsync(TOKEN_KEYS.REFRESH_TOKEN)  \n    if (!refreshToken) return null  \n  \n    const response = await fetch(`${urls.AUTH_URL}/token?grant_type=refresh_token`, {  \n      method: \"POST\",  \n      headers: {  \n        \"Content-Type\": \"application/json\",  \n        apikey: ANON_KEY,  \n      },  \n      body: JSON.stringify({ refresh_token: refreshToken }),  \n    })  \n  \n    if (!response.ok) {  \n      await clearTokens()  \n      return null  \n    }  \n  \n    const data = await response.json()  \n    if (data.access_token) {  \n      await storeTokens(data.access_token, data.refresh_token || refreshToken)  \n      return data.access_token  \n    }  \n  \n    return null  \n  } catch (error) {  \n    console.error(\"Error refreshing token:\", error)  \n    return null  \n  }  \n}  \n  \n// Get valid access token (with automatic refresh)  \nasync function getValidAccessToken(): Promise<string | null> {  \n  try {  \n    let accessToken = await SecureStore.getItemAsync(TOKEN_KEYS.ACCESS_TOKEN)  \n    if (!accessToken) return null  \n  \n    if (isTokenExpired(accessToken)) {  \n      console.log(\"Token expired, attempting refresh...\")  \n      accessToken = await refreshAccessToken()  \n    }  \n  \n    return accessToken  \n  } catch (error) {  \n    console.error(\"Error getting valid access token:\", error)  \n    return null  \n  }  \n}  \n  \n// Performance monitoring  \ninterface RequestMetrics {  \n  path: string  \n  method: string  \n  duration: number  \n  status: number  \n  timestamp: number  \n}  \n  \nconst requestMetrics: RequestMetrics[] = []  \n  \nexport function getRequestMetrics(): RequestMetrics[] {  \n  return [...requestMetrics]  \n}  \n  \nexport function clearRequestMetrics() {  \n  requestMetrics.length = 0  \n}  \n  \n// ÚNICA función request - sin duplicados  \nexport async function request(  \n  method: string,  \n  path: string,  \n  options: {  \n    params?: Record<string, any>  \n    body?: any  \n    headers?: Record<string, string>  \n    binary?: boolean  \n    retryOnAuth?: boolean  \n    timeout?: number  \n  } = {},  \n): Promise<any> {  \n  const startTime = Date.now()  \n  let status = 0  \n  \n  const {   \n    params,   \n    body,   \n    headers = {},   \n    binary = false,   \n    retryOnAuth = true,  \n    timeout = 30000   \n  } = options  \n  \n  try {  \n    let url = `${urls.REST_URL}${path}`  \n    if (params) {  \n      const searchParams = new URLSearchParams()  \n      Object.entries(params).forEach(([key, value]) => {  \n        if (value !== undefined) {  \n          searchParams.append(key, String(value))  \n        }  \n      })  \n      if (searchParams.toString()) {  \n        url += `?${searchParams.toString()}`  \n      }  \n    }  \n  \n    const requestHeaders: Record<string, string> = {  \n      apikey: ANON_KEY,  \n      ...headers,  \n    }  \n  \n    const token = await getValidAccessToken()  \n    if (token) {  \n      requestHeaders[\"Authorization\"] = `Bearer ${token}`  \n    }  \n  \n    if (!binary) {  \n      requestHeaders[\"Content-Type\"] = \"application/json\"  \n    }  \n  \n    const controller = new AbortController()  \n    const timeoutId = setTimeout(() => controller.abort(), timeout)  \n  \n    const response = await fetch(url, {  \n      method,  \n      headers: requestHeaders,  \n      body: body ? (binary ? body : JSON.stringify(body)) : undefined,  \n      signal: controller.signal,  \n    })  \n  \n    clearTimeout(timeoutId)  \n  \n    if (!response.ok && response.status === 401 && retryOnAuth) {  \n      console.log(\"Auth error, attempting token refresh and retry...\")  \n      const newToken = await refreshAccessToken()  \n      if (newToken) {  \n        requestHeaders[\"Authorization\"] = `Bearer ${newToken}`  \n        const retryResponse = await fetch(url, {  \n          method,  \n          headers: requestHeaders,  \n          body: body ? (binary ? body : JSON.stringify(body)) : undefined,  \n        })  \n  \n        if (retryResponse.ok) {  \n          status = 200  \n          try {  \n            return await retryResponse.json()  \n          } catch {  \n            return null  \n          }  \n        }  \n      }  \n    }  \n  \n    if (!response.ok) {  \n      let errorData  \n      try {  \n        errorData = await response.json()  \n      } catch {  \n        errorData = { message: response.statusText }  \n      }  \n      status = response.status  \n      throw {  \n        code: errorData.code || response.status,  \n        message: errorData.message || \"Request failed\",  \n        details: errorData.details || null,  \n        status: response.status  \n      }  \n    }  \n  \n    status = 200  \n    try {  \n      return await response.json()  \n    } catch {  \n      return null  \n    }  \n  } catch (error: any) {  \n    if (error.name === 'AbortError') {  \n      throw {  \n        code: 'TIMEOUT',  \n        message: 'Request timeout',  \n        details: `Request took longer than ${timeout}ms`  \n      }  \n    }  \n    status = error.status || 500  \n    throw error  \n  } finally {  \n    const duration = Date.now() - startTime  \n      \n    requestMetrics.push({  \n      path,  \n      method,  \n      duration,  \n      status,  \n      timestamp: startTime  \n    })  \n      \n    // Keep only last 100 metrics  \n    if (requestMetrics.length > 100) {  \n      requestMetrics.shift()  \n    }  \n  }  \n}  \n  \nexport async function authSignIn(email: string, password: string) {  \n  const response = await fetch(`${urls.AUTH_URL}/token?grant_type=password`, {  \n    method: \"POST\",  \n    headers: {  \n      \"Content-Type\": \"application/json\",  \n      apikey: ANON_KEY,  \n    },  \n    body: JSON.stringify({ email, password }),  \n  })  \n  \n  if (!response.ok) {  \n    const error = await response.json()  \n    throw new Error(error.error_description || \"Sign in failed\")  \n  }  \n  \n  const data = await response.json()  \n  \n  if (data.access_token) {  \n    await storeTokens(data.access_token, data.refresh_token)  \n    await SecureStore.setItemAsync(TOKEN_KEYS.USER_SESSION, JSON.stringify({  \n      email,  \n      loginTime: Date.now(),  \n      lastActivity: Date.now()  \n    }))  \n  }  \n  \n  return data  \n}  \n  \nexport async function authSignUp(email: string, password: string) {  \n  const response = await fetch(`${urls.AUTH_URL}/signup`, {  \n    method: \"POST\",  \n    headers: {  \n      \"Content-Type\": \"application/json\",  \n      apikey: ANON_KEY,  \n    },  \n    body: JSON.stringify({ email, password }),  \n  })  \n  \n  if (!response.ok) {  \n    const error = await response.json()  \n    throw new Error(error.error_description || \"Sign up failed\")  \n  }  \n  \n  const data = await response.json()  \n  \n  if (data.access_token) {  \n    await storeTokens(data.access_token, data.refresh_token)  \n    await SecureStore.setItemAsync(TOKEN_KEYS.USER_SESSION, JSON.stringify({  \n      email,  \n      signupTime: Date.now(),  \n      lastActivity: Date.now()  \n    }))  \n  }  \n  \n  return data  \n}  \n  \nexport async function authSignOut() {  \n  try {  \n    const token = await SecureStore.getItemAsync(TOKEN_KEYS.ACCESS_TOKEN)  \n    if (token) {  \n      await fetch(`${urls.AUTH_URL}/logout`, {  \n        method: \"POST\",  \n        headers: {  \n          \"Content-Type\": \"application/json\",  \n          apikey: ANON_KEY,  \n          \"Authorization\": `Bearer ${token}`  \n        },  \n      }).catch(() => {})  \n    }  \n  } catch (error) {  \n    console.warn(\"Error during server logout:\", error)  \n  }  \n  \n  await clearTokens()  \n}  \n  \nexport async function getCurrentUserId(): Promise<string | null> {  \n  try {  \n    const token = await getValidAccessToken()  \n    if (!token) return null  \n  \n    const payload = JSON.parse(atob(token.split(\".\")[1]))  \n    return payload.sub || null  \n  } catch (error) {  \n    console.error(\"Error getting current user ID:\", error)  \n    return null  \n  }  \n}  \n  \nexport async function isAuthenticated(): Promise<boolean> {  \n  try {  \n    const token = await getValidAccessToken()  \n    return !!token  \n  } catch {  \n    return false  \n  }  \n}  \n  \nexport async function updateLastActivity() {  \n  try {  \n    const sessionData = await SecureStore.getItemAsync(TOKEN_KEYS.USER_SESSION)  \n    if (sessionData) {  \n      const session = JSON.parse(sessionData)  \n      session.lastActivity = Date.now()  \n      await SecureStore.setItemAsync(TOKEN_KEYS.USER_SESSION, JSON.stringify(session))  \n    }  \n  } catch (error) {  \n    console.warn(\"Error updating last activity:\", error)  \n  }  \n}  \n  \nexport async function getSessionInfo() {  \n  try {  \n    const sessionData = await SecureStore.getItemAsync(TOKEN_KEYS.USER_SESSION)  \n    return sessionData ? JSON.parse(sessionData) : null  \n  } catch {  \n    return null  \n  }  \n}  \n  \n// Network status monitoring  \nexport async function checkNetworkStatus(): Promise<boolean> {  \n  // En desarrollo, siempre retornar true para evitar errores  \n  if (__DEV__) {  \n    return Promise.resolve(true);  \n  }  \n  \n  try {  \n    const response = await fetch(`${urls.REST_URL}/health`, {  \n      method: 'HEAD',  \n      headers: {  \n        'apikey': ANON_KEY,  \n        'Authorization': `Bearer ${await getValidAccessToken()}`  \n      }  \n    })  \n    return response.ok  \n  } catch (error) {  \n    console.error('Network status check failed:', error)  \n    return false  \n  }  \n}  \n  \n// Batch requests for better performance  \nexport async function batchRequest(requests: Array<{  \n  method: string  \n  path: string  \n  options?: any  \n}>) {  \n  const promises = requests.map(req =>   \n    request(req.method, req.path, req.options).catch(error => ({ error }))  \n  )  \n  return await Promise.all(promises)  \n}  \n  \n// Upload progress tracking  \nexport async function uploadWithProgress(  \n  path: string,   \n  file: any,   \n  onProgress?: (progress: number) => void  \n): Promise<any> {  \n  return new Promise((resolve, reject) => {  \n    const xhr = new XMLHttpRequest()  \n      \n    xhr.upload.addEventListener('progress', (event) => {  \n      if (event.lengthComputable && onProgress) {  \n        const progress = (event.loaded / event.total) * 100  \n        onProgress(progress)  \n      }  \n    })  \n      \n    xhr.addEventListener('load', () => {  \n      if (xhr.status >= 200 && xhr.status < 300) {  \n        try {  \n          resolve(JSON.parse(xhr.responseText))  \n        } catch {  \n          resolve(xhr.responseText)  \n        }  \n      } else {  \n        reject(new Error(`Upload failed: ${xhr.status} ${xhr.statusText}`))  \n      }  \n    })  \n      \n    xhr.addEventListener('error', () => {  \n      reject(new Error('Upload failed'))  \n    })  \n      \n    xhr.addEventListener('abort', () => {  \n      reject(new Error('Upload cancelled'))  \n    })  \n      \n    xhr.open('POST', `${urls.STORAGE_URL}${path}`)  \n    xhr.setRequestHeader('apikey', ANON_KEY)  \n      \n    getValidAccessToken().then(token => {  \n      if (token) {  \n        xhr.setRequestHeader('Authorization', `Bearer ${token}`)  \n      }  \n      xhr.send(file)  \n    })  \n  })  \n}  \n  \n// Connection retry with exponential backoff  \nexport async function requestWithRetry(  \n  method: string,  \n  path: string,  \n  options: any = {},  \n  maxRetries: number = 3  \n): Promise<any> {  \n  let lastError: any  \n    \n  for (let attempt = 0; attempt <= maxRetries; attempt++) {  \n    try {  \n      return await request(method, path, options)  \n    } catch (error: any) {  \n      lastError = error  \n        \n      if (error.status >= 400 && error.status < 500) {  \n        throw error  \n      }  \n        \n      if (attempt < maxRetries) {  \n        const delay = Math.min(1000 * Math.pow(2, attempt), 10000) // Max 10s  \n        console.log(`Request failed, retrying in ${delay}ms... (attempt ${attempt + 1}/${maxRetries})`)  \n        await new Promise(resolve => setTimeout(resolve, delay))  \n      }  \n    }  \n  }  \n    \n  throw lastError  \n}  \n  \n// Cache management for offline support  \nconst requestCache = new Map<string, { data: any; timestamp: number; ttl: number }>()  \n  \nexport async function requestWithCache(  \n  method: string,  \n  path: string,  \n  options: any = {},  \n  ttl: number = 300000 // 5 minutes default  \n): Promise<any> {  \n  const cacheKey = `${method}:${path}:${JSON.stringify(options.params || {})}`  \n  const cached = requestCache.get(cacheKey)  \n    \n  // Return cached data if still valid  \n  if (cached && Date.now() - cached.timestamp < cached.ttl) {  \n    return cached.data  \n  }  \n    \n  try {  \n    const data = await request(method, path, options)  \n      \n    // Cache successful GET requests only  \n    if (method === 'GET' && data) {  \n      requestCache.set(cacheKey, {  \n        data,  \n        timestamp: Date.now(),  \n        ttl  \n      })  \n    }  \n      \n    return data  \n  } catch (error) {  \n    // Return cached data if available during errors  \n    if (cached) {  \n      console.warn('Request failed, returning cached data:', error)  \n      return cached.data  \n    }  \n    throw error  \n  }  \n}  \n  \n// Clear cache  \nexport function clearRequestCache() {  \n  requestCache.clear()  \n}  \n  \n// Real-time connection status  \nlet isOnline = true  \nlet connectionListeners: Array<(online: boolean) => void> = []  \n  \nexport function addConnectionListener(callback: (online: boolean) => void) {  \n  connectionListeners.push(callback)  \n}  \n  \nexport function removeConnectionListener(callback: (online: boolean) => void) {  \n  connectionListeners = connectionListeners.filter(cb => cb !== callback)  \n}  \n  \nexport function getConnectionStatus(): boolean {  \n  return isOnline  \n}  \n  \n// Monitor connection status  \nsetInterval(async () => {  \n  const wasOnline = isOnline  \n  isOnline = await checkNetworkStatus()  \n    \n  if (wasOnline !== isOnline) {  \n    connectionListeners.forEach(callback => callback(isOnline))  \n  }  \n}, 30000) // Check every 30 seconds  \n  \n// Request queue for offline support  \ninterface QueuedRequest {  \n  id: string  \n  method: string  \n  path: string  \n  options: any  \n  timestamp: number  \n  retries: number  \n}  \n  \nconst requestQueue: QueuedRequest[] = []  \n  \nexport async function queueRequest(method: string, path: string, options: any = {}) {  \n  const queuedRequest: QueuedRequest = {  \n    id: `${Date.now()}-${Math.random()}`,  \n    method,  \n    path,  \n    options,  \n    timestamp: Date.now(),  \n    retries: 0  \n  }  \n    \n  requestQueue.push(queuedRequest)  \n    \n  // Try to process queue if online  \n  if (isOnline) {  \n    processRequestQueue()  \n  }  \n    \n  return queuedRequest.id  \n}  \n  \nasync function processRequestQueue() {  \n  if (!isOnline || requestQueue.length === 0) return  \n    \n  const queuedRequest = requestQueue.shift()  \n  if (!queuedRequest) return  \n    \n  try {  \n    await requestWithRetry(queuedRequest.method, queuedRequest.path, queuedRequest.options)  \n    console.log(`Queued request processed: ${queuedRequest.method} ${queuedRequest.path}`)  \n  } catch (error) {  \n    console.error(`Failed to process queued request:`, error)  \n      \n    // Re-queue if not too old and hasn't been retried too many times  \n    if (Date.now() - queuedRequest.timestamp < 3600000 && queuedRequest.retries < 3) { // 1 hour max age  \n      queuedRequest.retries++  \n      requestQueue.push(queuedRequest)  \n    }  \n  }  \n    \n  // Process next request  \n  if (requestQueue.length > 0) {  \n    setTimeout(processRequestQueue, 1000)  \n  }  \n}  \n  \n// Auto-process queue when connection is restored  \naddConnectionListener((online) => {  \n  if (online) {  \n    processRequestQueue()  \n  }  \n})"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}